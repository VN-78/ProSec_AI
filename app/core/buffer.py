import threading
import time
from typing import List, Callable
from app.models.log import ParsedLogEvent

class LogBuffer:
    """A thread-safe sliding window buffer for collecting parsed log events.

    This class runs a background timer that periodically flushes collected
    events and passes them to a registered callback function (the detector).

    Attributes:
        interval_seconds: The time window duration before flushing.
        callback: The function to execute when the buffer flushes.
    """

    def __init__(self, interval_seconds: int, callback: Callable[[List[ParsedLogEvent]], None]) -> None:
        """Initializes the LogBuffer.

        Args:
            interval_seconds: How often (in seconds) to flush the buffer.
            callback: A function that accepts a List[ParsedLogEvent].
        """
        self.interval_seconds = interval_seconds
        self.callback = callback
        
        self._buffer: List[ParsedLogEvent] = []
        self._lock = threading.Lock()
        self._running = False
        self._thread: threading.Thread | None = None

    def add_event(self, event: ParsedLogEvent) -> None:
        """Safely appends a new parsed log to the buffer.

        Args:
            event: The structured log event generated by Drain3.
        """
        with self._lock:
            self._buffer.append(event)

    def start(self) -> None:
        """Starts the background timer thread for flushing the buffer."""
        if self._running:
            return
            
        self._running = True
        self._thread = threading.Thread(target=self._flush_loop, daemon=True)
        self._thread.start()
        print(f"[*] LogBuffer started. Flushing every {self.interval_seconds} seconds.")

    def stop(self) -> None:
        """Stops the background timer thread gracefully."""
        self._running = False
        if self._thread:
            self._thread.join()

    def _flush_loop(self) -> None:
        """The internal loop that triggers the callback and clears the buffer."""
        while self._running:
            time.sleep(self.interval_seconds)
            
            # Quickly swap the buffer out under a lock to minimize blocking
            with self._lock:
                events_to_flush = self._buffer
                self._buffer = []

            # Execute the ML detection on the flushed batch
            # We do this outside the lock so ML processing doesn't block incoming logs
            if events_to_flush:
                self.callback(events_to_flush)
            else:
                # If no logs occurred in this window, pass an empty list
                self.callback([])